using System.Numerics;

namespace RubiksCube.Core.Graphics;

public static partial class Renderer
{
    public static Matrix4x4 DrawModel(Model model, Vector3 position, Vector3 rotation, Vector3 scale, Color tint)
    {
        // Calculate transformation matrix from function parameters
        // Get transform matrix (rotation -> scale -> translation)
        var matScale = MatrixScale(scale.X, scale.Y, scale.Z);
        var matRotation = MatrixRotateXYZ(rotation * DEG2RAD);
        var matTranslation = MatrixTranslate(position.X, position.Y, position.Z);

        var matTransform = MatrixMultiply(MatrixMultiply(matScale, matRotation), matTranslation);

        // Combine model transformation matrix (model.transform) with matrix generated by function parameters (matTransform)
        model.transform = MatrixMultiply(model.transform, matTransform);

        DrawModel(model, tint);

        return model.transform;
    }
    
    public static Matrix4x4 DrawModel(Model model, Vector3 position, Quaternion rotation, Vector3 scale, Color tint)
    {
        // Calculate transformation matrix from function parameters
        // Get transform matrix (rotation -> scale -> translation)
        var matScale = MatrixScale(scale.X, scale.Y, scale.Z);
        var matRotation = Matrix4x4.CreateFromQuaternion(rotation);
        var matTranslation = MatrixTranslate(position.X, position.Y, position.Z);

        var matTransform = MatrixMultiply(MatrixMultiply(matScale, matRotation), matTranslation);

        // Combine model transformation matrix (model.transform) with matrix generated by function parameters (matTransform)
        model.transform = MatrixMultiply(model.transform, matTransform);

        DrawModel(model, tint);

        return model.transform;
    }

    public static unsafe void DrawModel(Model model, Color tint)
    {
        for (var i = 0; i < model.meshCount; i++)
        {
            var color = model.materials[model.meshMaterial[i]].maps[(int)MaterialMapIndex.MATERIAL_MAP_DIFFUSE].color;

            var colorTint = Color.WHITE;
            colorTint.r = (byte)(color.r / 255.0f * (tint.r / 255.0f) * 255.0f);
            colorTint.g = (byte)(color.g / 255.0f * (tint.g / 255.0f) * 255.0f);
            colorTint.b = (byte)(color.b / 255.0f * (tint.b / 255.0f) * 255.0f);
            colorTint.a = (byte)(color.a / 255.0f * (tint.a / 255.0f) * 255.0f);

            model.materials[model.meshMaterial[i]].maps[(int)MaterialMapIndex.MATERIAL_MAP_DIFFUSE].color = colorTint;
            DrawMesh(model.meshes[i], model.materials[model.meshMaterial[i]], model.transform);
            model.materials[model.meshMaterial[i]].maps[(int)MaterialMapIndex.MATERIAL_MAP_DIFFUSE].color = color;
        }
    }
}